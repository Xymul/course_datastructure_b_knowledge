# 数组和广义表

## 稀疏矩阵

### 稀疏矩阵的三元组表示法

#### 矩阵的转置算法

在三元组表示的稀疏矩阵中，由于每一个非0元素的存储都是按行排序的（行相同则按列排序）：
```
 data[i] | row | col | value |
------------------------------
 data[1] |  1  |  2  |  12   |            0  12  9  0   0  0   0  0
 data[2] |  1  |  3  |   9   |            0  0   0  0   0  0   0  0
 data[3] |  3  |  1  |  -3   |           -3  0   0  0   0  14  0  0
 data[4] |  3  |  6  |  14   |            0  0  24  0   0  0   0  0
 data[5] |  4  |  3  |  24   |            0  18  0  0   0  0   0  0
 data[6] |  5  |  2  |  18   |           15  0   0  -7  0  0   0  0
 data[7] |  6  |  1  |  15   |
 data[8] |  6  |  4  |  -7   |
```

转置时，如果只是简单将行列互换，就会打乱顺序：
```
 data[i] | row | col | value |
------------------------------
 data[1] |  2  |  1  |  12   |
 data[2] |  3  |  1  |   9   |
 data[3] |  1  |  3  |  -3   |
 data[4] |  6  |  3  |  14   |
 data[5] |  3  |  4  |  24   |
 data[6] |  2  |  5  |  18   |
 data[7] |  1  |  6  |  15   |
 data[8] |  4  |  6  |  -7   |
```

面对这种情况，我们有两种转置方法：

**普通转置算法**

也就是在交换行列的时候同时进行排序，时间复杂度为O(mn)，m为矩阵的行数，也可以是矩阵的列数，n为矩阵的非0元素个数。

具体思路是，先将第一行（转置后是第一列）的元素放到正确的位置，然后再将第二行的元素放到正确的位置，以此类推。（如果按列来转置也是一样的）

如果在转置前就选择按行或者按列转置，那么时间复杂度就是O(min(m1, m2)\*n)。

**快速转置算法**

快速转置算法的核心思想是：
- 计算稀疏矩阵每一列中非0元素的个数
- 然后计算稀疏矩阵每一列中第一个非零元素在转置后矩阵中的位置

我们用`cnum[col]`来表示稀疏矩阵每一列中非0元素的个数，例如`cnum[1]`就是表示原始矩阵中每一列非0元素的个数。

然后我们需要计算原始矩阵每一列中第一个非0元素在转置后矩阵中的位置，用`cpos[col]`来表示。

计算方式是：
```c++
cpos[1] = 1
cpos[i] = cpos[i - 1] + cnum[i - 1]; // i >= 2
```

原理如下：
- 第一列转置后是第一行，而第一行的第一个非0元素总是在稀疏矩阵的头部
- 原始矩阵的列转置后变为行，所以`cnum[col]`就代表了转置后的某一行的元素个数
- 所以下一行的第一个非0元素的位置就是上一行非0元素的位置加上上一行的元素个数

> [!NOTE]
> 比如这样一个原始矩阵：
> ```
> data[0] | data[1] | data[2] | data[3]
> ```
> 其中`data[3]`和`data[2]`在第一列，`data[0]`在第二列，`data[1]`在第三列
> 
> 转置以后变成了：
> ```
> data[2] | data[3] | data[0] | data[1]
> ```
> 由于`data[3]`和`data[2]`在第一列，所以转置以后它们位于第一行，而`data[2]`原来在`data[3]`前面，所以`data[2]`的行比`data[3]`的行要小，所以转置以后`data[2]`仍然在`data[3]`前面，也就是第一行的第一个非0元素。因此它的位置是1；
> 
> 对于`data[0]`而言，它是第二行的第一个非0元素，所以它前面的所有非0元素在第一行，因此，它的位置就等于第一行的第一个非0元素的位置加上第一行非0元素的个数，这里就是1+2=3。
> 
> 同样地，`data[1]`转置后的位置按照上述方法算出来为4

有了`cpos`数组，我们就可以对矩阵进行转置了：

通过`cpos`数组，查询非0元素在转置后矩阵的正确位置，然后将非零元素放到转置后矩阵的正确位置上。

同时，每放置一个非0元素，这个非零元素对应的`cpos[col]`要+1。这是因为将原来某一列非0元素放到正确位置后，该列的下一个非0元素的正确位置是刚才非0元素的后面。

> [!NOTE]
> 例如这里有一个矩阵：
> ```
> 0 0 3                          0 2 1
> 2 0 0      =====转置后======>   0 0 0
> 1 0 0                          3 0 0
> data[1] = 3                    data[1] = 2
> data[2] = 2                    data[2] = 1
> data[3] = 1                    data[3] = 3
> ```
> 当把`2`放到矩阵中的正确位置以后，由于`1`是同一列中`2`的下一个非0元素，所以转置后`1`应该在`2`的后面。

快速稀疏矩阵转置算法的时间复杂度是O(m+n)，其中m是非0元素的个数，n是矩阵的列数。
